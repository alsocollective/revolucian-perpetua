<html>
<head>
	<title></title>
</head>
<body>

</body>
<script type="text/javascript">

//http://stackoverflow.com/questions/3760506/smoothing-values-over-time-moving-average-or-something-better
//http://stackoverflow.com/questions/2272527/how-do-you-use-a-moving-average-to-filter-out-accelerometer-values-in-iphone-os
//http://stackoverflow.com/questions/10359907/array-sum-and-average

/* Different Styles of moving averages create varied result see the comparison csv:

avg1: Existing average algorithm previously implemented, but scaled to 10 values
avg2: var sum = averageList.reduce(function(a, b) { return a + b });
		var avgNow = sum / averageList.length;
	Successful and clean
avg3: Not as good as expected
		// filtered = timeConstant * filtered + (1.0 - timeConstant) * unfiltered;
	    //mvAvgX = tc * mvAvgX + (1.0 - tc) * x;
		mvAvgY = tc * mvAvgY + (1.0 - tc) * z;

avg4: Tiny and fast, gave clean results
		mvAvg = (z*tc)+(mvAvg*(1.0-tc));


//a(i+1) = tiny*data(i+1) + (1.0-tiny)*a(i)

//workingAverage = (newValue*smoothingFactor) + ( workingAverage * ( 1.0 - smoothingFactor) )
var mvAvg = 0;
var mvAvgX = 0;
var mvAvgY = 0;

var tc = 0.4;

var averageList = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	avLength = averageList.length,
	average = 0,
	difference = 500,
	time = (new Date()).getTime(),
	arrayOfDiff = [],
	diffLength = avLength,
	diffAvg = 0,
	diffoffSet = 0;
	current = 0;

function handleMotionEvent(event) {

		var x = event.accelerationIncludingGravity.x;
	    var y = event.accelerationIncludingGravity.y;
	    var z = event.accelerationIncludingGravity.z;

	    //add new Value to array and remove oldest
		averageList.shift();
		averageList[avLength] = z;
		findAverage();

		var sum = averageList.reduce(function(a, b) { return a + b });
		var avgNow = sum / averageList.length;

		//console.log(Math.floor(avgNow)+" : "+z);

		//console.log(""+Math.floor(avgNow),Math.floor(mvAvgY),Math.floor(mvAvg));

		console.log(""+findAverage()+","+avgNow+","+mvAvgY+","+mvAvg);

		/*console.log(avLength);

		for(i=0;i<avLength;i++){
			console.log(averageList[i]);
		}*/

	    mvAvg = (z*tc)+(mvAvg*(1.0-tc));

	    // filtered = timeConstant * filtered + (1.0 - timeConstant) * unfiltered;

	    //mvAvgX = tc * mvAvgX + (1.0 - tc) * x;
		mvAvgY = tc * mvAvgY + (1.0 - tc) * z;

	    //console.log(mvAvg,z);

	    //console.log(findAverage() + " : " + mvAvgX + " : " + x);
	}

	function findAverage() {
		var a = 0,
			preAv = average,
			diffadding = 0;

		average = 0,
		difference = 0;
		for (a = 0; a < avLength; ++a) {
			average += averageList[a];
			difference += preAv - averageList[a]
			diffadding += arrayOfDiff[a];
		}
		difference = Math.floor(difference / avLength);
		average = average / avLength;

		arrayOfDiff.shift();
		arrayOfDiff[diffLength] = difference;
		diffAvg = Math.floor(diffadding / diffLength)
		diffoffSet = difference - diffAvg


		if (!average) {
			average = 0;
		}

		return average;
	}

window.addEventListener("devicemotion", handleMotionEvent, true);


	/*var rawArray = [];
	var time = (new Date()).getTime()

	function handleMotionEvent(event) {

	    //var x = event.accelerationIncludingGravity.x;
	    //var y = event.accelerationIncludingGravity.y;
	    var z = event.accelerationIncludingGravity.z;

	    rawArray.push(z);

	    //Make array, only begin if 100+ values have been collected
	    if(rawArray.length 100){
	    	HIGHPASS(rawArray,100,time);
	    	//console.log(rawArray.length + " Val: " + rawArray[50]);
	    }else{
	    	console.log("Not enough data.");
	    }
	}

window.addEventListener("devicemotion", handleMotionEvent, true);

function HIGHPASS (dataIn,timeInterval,constantTime) {
	var liveData = dataIn[0];
	//???
	y[0] = x[0];

	for(i=0; i < n.length; i++){
		y[i] := α * y[i-1] + α * (x[i] - x[i-1])
	}

	return y

	console.log(rawArray.length + " Val: " + rawArray[50]);
}

// function HIGHPASS (real[x],DT,RC) {
// 	var real[0];
// 	//lowpass smooths high pass isolates peaks

// 	

// 	//α is ALPHA
// }

// Return RC high-pass filter output samples, given input samples,
 // time interval dt, and time constant RC
 
 /*function highpass(real[0..n] x, real dt, real RC)
   var real[0..n] y
   var real α := RC / (RC + dt)
   y[0] := x[0]
   for i from 1 to n
     y[i] := α * y[i-1] + α * (x[i] - x[i-1])
   return y*/



//We need orientation combined with a highpass filter to make this work.


</script>
</html>